# 生命周期

<Bookmark>![Vue2生命周期](https://v2.cn.vuejs.org/images/lifecycle.png)</Bookmark>
<Bookmark>![Vue3生命周期](https://cn.vuejs.org/assets/lifecycle.16e4c08e.png)</Bookmark>

| 生命周期      | 描述                               |
| :------------ | :--------------------------------- |
| beforeCreate  | 组件实例被创建之初                 |
| created       | 组件实例已经完全创建               |
| beforeMount   | 组件挂载之前                       |
| mounted       | 组件挂载到实例上去之后             |
| beforeUpdate  | 组件数据发生变化，更新之前         |
| updated       | 组件数据更新之后                   |
| beforeDestroy | 组件实例销毁之前                   |
| destroyed     | 组件实例销毁之后                   |
| activated     | keep-alive 缓存的组件激活时        |
| deactivated   | keep-alive 缓存的组件停用时调用    |
| errorCaptured | 捕获一个来自子孙组件的错误时被调用 |

![](https://static.vue-js.com/44114780-3aca-11eb-85f6-6fac77c0c9b3.png)

**beforeCreate -> created**

- 初始化`vue`实例，进行数据观测

**created**

- 完成数据观测，属性与方法的运算，`watch`、`event`事件回调的配置
- 可调用`methods`中的方法，访问和修改data数据触发响应式渲染`dom`，可通过`computed`和`watch`完成数据计算
- 此时`vm.$el` 并没有被创建

**created -> beforeMount**

- 判断是否存在`el`选项，若不存在则停止编译，直到调用`vm.$mount(el)`才会继续编译
- 优先级：`render` > `template` > `outerHTML`
- `vm.el`获取到的是挂载`DOM`的

**beforeMount**

- 在此阶段可获取到`vm.el`
- 此阶段`vm.el`虽已完成DOM初始化，但并未挂载在`el`选项上

**beforeMount -> mounted**

- 此阶段`vm.el`完成挂载，`vm.$el`生成的`DOM`替换了`el`选项所对应的`DOM`

**mounted**

- `vm.el`已完成`DOM`的挂载与渲染，此刻打印`vm.$el`，发现之前的挂载点及内容已被替换成新的DOM

**beforeUpdate**

- 更新的数据必须是被渲染在模板上的（`el`、`template`、`render`之一）
- 此时`view`层还未更新
- 若在`beforeUpdate`中再次修改数据，不会再次触发更新方法

**updated**

- 完成`view`层的更新
- 若在`updated`中再次修改数据，会再次触发更新方法（`beforeUpdate`、`updated`）

**beforeDestroy**

- 实例被销毁前调用，此时实例属性与方法仍可访问

**destroyed**

- 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器
- 并不能清除DOM，仅仅销毁实例

## 实例挂载的过程

Vue 实例的挂载过程是一个相对复杂但有序的过程，它涉及到 Vue 的内部机制以及 DOM 的操作。下面是一个简化的 Vue 实例挂载过程的概述：

1. **创建 Vue 实例**：首先，我们使用 `new Vue({...})` 来创建一个 Vue 实例。在这个对象中，我们可以定义数据（`data`）、方法（`methods`）、生命周期钩子（`lifecycle hooks`）等。
2. **初始化**：Vue 在内部进行了一系列的初始化操作。这包括解析选项、设置响应式数据、解析模板等。在这个过程中，Vue 会遍历 `data` 中的每一个属性，并使用 Object.defineProperty 将它们转化为 getter/setter，以实现数据的响应式。
3. **编译模板**：如果提供了模板（可以是字符串形式的模板，也可以是挂载点元素的 in-DOM HTML），Vue 会将其编译成渲染函数的字符串形式。这个过程涉及到解析模板语法、生成虚拟 DOM 等步骤。
4. **生成渲染函数**：编译后的模板字符串会被转换成 JavaScript 的渲染函数。这个渲染函数是一个纯 JavaScript 函数，当数据发生变化时，它会根据最新的数据生成一个新的虚拟 DOM 树。
5. **挂载过程开始**：在 Vue 实例的 `$mount` 方法被调用时，挂载过程正式开始。如果没有提供 `el` 选项，则 Vue 实例会处于“未挂载”状态，此时可以通过 `$mount(elementOrSelector)` 手动挂载到一个元素上。
6. **创建根虚拟节点**：使用之前生成的渲染函数，Vue 会根据当前的数据状态生成一个根虚拟节点（Virtual Node）。这个虚拟节点是 Vue 用来描述真实 DOM 结构的一个轻量级对象。
7. **创建或更新真实 DOM**：Vue 使用一个名为 `patch` 的函数来比较旧的虚拟 DOM 和新的虚拟 DOM，并找出它们之间的差异。然后，Vue 会根据这些差异来更新真实的 DOM。这个过程被称为“差异算法”或“虚拟 DOM diffing”。
8. **挂载完成**：当真实 DOM 被更新以匹配虚拟 DOM 后，Vue 实例就成功挂载到了指定的元素上。此时，Vue 实例会触发 `mounted` 生命周期钩子。