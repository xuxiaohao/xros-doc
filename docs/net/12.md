# 浏览器渲染流程,回流与重绘

![](/images/net/render.jpg)

- 1.浏览器无法直接使用HTML，需要将HTML转化成DOM树。（`document`）
- 2.浏览器无法解析纯文本的`CSS`样式，需要对`CSS`进行解析,解析成`styleSheets`。`CSSOM`（`document.styleSeets`）
- 3.计算出DOM树中每个节点的具体样式（Attachment）
- 4.创建渲染（布局）树，将DOM树中可见节点，添加到布局树中。并计算节点渲染到页面的坐标位置。（layout）
- 5.通过布局树，进行分层 （根据定位属性、透明属性、transform属性、clip属性等）生产图层树。
- 6.将不同图层进行绘制，转交给合成线程处理。最终生产页面，并显示到浏览器上 (Painting,Display)

## DOM 是如何生成的？

![](/images/net/dom-render.jpg)

- 当服务端返回的类型是 text/html 时，浏览器会将收到的数据通过 HTMLParser 进行解析 (边下载边解析)
- 在解析前会执行预解析操作，会预先加载 JS、CSS 等文件
- 字节流 -> 分词器 -> Tokens -> 根据 token 生成节点 -> 插入到 DOM 树中
- 遇到 js:在解析过程中遇到 script 标签，HTMLParser 会停止解析，（下载）执行对应的脚本。
- 在 js 执行前，需要等待当前脚本之上的所有 CSS 加载解析完毕（js 是依赖 css 的加载）

> CSS 样式文件尽量放在页面头部，CSS 加载不会阻塞 DOM tree 解析,浏览器会用解析出的 DOM TREE 和 CSSOM 进行渲染，不会出现闪烁问题。如果 CSS 放在底部，浏览是边解析边渲染，渲染出的结果不包含样式，后续会发生重绘操作。
> 

> JS 文件放在 HTML 底部，防止 JS 的加载、解析、执行堵塞页面后续的正常渲染

```js
const express = require("express");
const path = require("path");
const app = express();
// 延迟返回css 看效果
app.get("/index.css", function (req, res) {
  setTimeout(() => {
    res.sendFile(path.resolve(__dirname, "index.css"));
  }, 1000);
});
// 延迟js 看效果
app.get("/index.js", function (req, res) {
  setTimeout(() => {
    res.sendFile(path.resolve(__dirname, "index.js"));
  }, 1000);
});
app.use(express.static(__dirname));
app.listen(3000);
```

## 回流与重绘

![](/images/net/rerender.png)

- 重排（回流）`Reflow`： 添加元素、删除元素、修改大小、移动元素位置、获取位置相关信息
- 重绘 `Repaint`：页面中元素样式的改变并不影响它在文档流中的位置。

> 我们应当尽可能减少重绘和回流。

### 强制同步布局问题

JavaScript 强制将计算样式和布局操作提前到当前的任务中

```html
<div id="app"></div>
<script>
    function reflow() {
        let el = document.getElementById('app');
        let node = document.createElement('h1');
        node.innerHTML = 'hello';
        el.appendChild(node);
        // 强制同步布局
        console.log(app.offsetHeight);
    }
    requestAnimationFrame(reflow)
</script
```

### 布局抖动问题

在一段 js 代码中，反复执行布局操作，就是布局抖动

```js
function reflow() {
  let el = document.getElementById("app");
  let node = document.createElement("h1");
  node.innerHTML = "hello";
  el.appendChild(node);
  // 强制同步布局
  console.log(app.offsetHeight);
}
window.addEventListener("load", function () {
  for (let i = 0; i < 100; i++) {
    reflow();
  }
});
```

### 减少回流与重绘

- 脱离文档流
- 渲染时给图片增加固定宽高
- 尽量使用 css3 动画
  ```html
  <style>
    /* ctrl+shift+p (show Rending 查看重绘操作) */
    @keyframes rotate {
      from {
        transform: rotate(0deg);
        /* width: 100px; */
      }
      to {
        transform: rotate(360deg);
        /* width: 500px; */
      }
    }
    #app {
      width: 100px;
      height: 100px;
      background: red;
      animation: rotate 0.2s linear infinite;
    }
  </style>
  <div id="app"></div>
  ```
- 可以使用 will-change 提取到单独的图层中
  ``` html
  <div style="will-change: transform">我是单独的图层</div>
  ``` 