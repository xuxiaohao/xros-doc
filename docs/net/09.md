# HTTP的发展1.1/2/3

## HTTP2
HTTP/2 主要的⽬标就是改进性能，兼容 HTTP/1.1。

![](/images/net/09-1.png)

- 问题1： HTTP/1.1 需要开启多个tcp连接，消耗性能。
- 问题2： HTTP/1.1 采用纯文本格式，在解析过程中会有歧义，性能差。
- 问题3： HTTP/1.1 不能乱序收发。
- 问题4： HTTP/1.1 中只能优化 body 并没有对头部进⾏处理

### 1. 多路复用

在⼀条TCP链接上可以乱序收发请求和响应，多个请求和响应之间不再有顺序关系。

![](/images/net/09-2.png)

- 有序，每一个流都有特定ID。奇数为客户端发送，偶数为服务端发送
- 双向，同一个流内，可以接受和发送消息。
- 并行，同一个TCP中，可以发送多个流。
- 创建、关闭，客户端和服务端都可以主动关闭当前流。

### 2. 二进制帧

![](/images/net/09-3.png)

- Length帧的⼤⼩， 2^24 帧最⼤不能超过 16M
- Type帧的类型：常⽤的就是 HEADERS，DATA
- Flags标志位：常⽤的是 END_HEADERS , END_STREAM , PRIORITY
- Stream Identifier 流的标号

> /Applications/chrome.app/Contents/MacOS/Google\ Chrome --ssl-key-log-file=/Users/jiangwen/tls/sslkeylog.log

### 3. 头部压缩

使⽤ HPACK 算法压缩HTTP头

- 废除起始⾏，全部移⼊到Header中去，采⽤**静态表**的⽅式压缩字段
- 如果是⾃定义Header，在发送的过程中会添加到**静态表**后，也就是所谓的**动态表**
- 对内容进⾏哈夫曼编码来减⼩体积
  

![](/images/net/09-4.png)

```
a->0  b->1 c->10 d->11  错误编码有歧义
a->00 b->01 c->10 d->11 f->110 无歧义
```

### 4. 服务端推送

服务端可以提前将可能会⽤到的资源主动推送到客户端。

## HTTP3
TCP为了保证可靠传输，如果在传输的过程中发⽣丢包，可能此时其他包已经接受完毕，但是仍要等待客户端重传丢失的包。这就是TCP协议本身队头阻塞的问题。


![](/images/net/09-5.png)

- HTTP/3中关键的改变，那就是把下层的 TCP 换成了 UDP 。 UDP ⽆序从⽽解决了**队头阻塞**的问题。
- QUIC 基于 UDP 之前说过 UDP 是⽆续的，连接速度⽐ TCP 快。
- QUIC 基于 UDP 实现了可靠传输、流量控制，引⼊流和多路复⽤。
- QUIC 全⾯采⽤加密通信, QUIC 使⽤了 TLS 1.3，⾸次连接只需要 1RTT。
- ⽀持**链接迁移**，不受 IP 及 port 影响⽽发⽣重连，通过 ConnectionID 进⾏链接。
- 使⽤ QPACK 进⾏头部压缩，提供更好的压缩比、更快的压缩和解压缩速度以及更大的灵活性。