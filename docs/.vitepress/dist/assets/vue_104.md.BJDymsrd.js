import{_ as c,D as r,c as a,I as o,w as l,j as d,a as e,a4 as i,o as n}from"./chunks/framework.2gWjYe7W.js";const V=JSON.parse('{"title":"生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"vue/104.md","filePath":"vue/104.md","lastUpdated":null}'),s={name:"vue/104.md"},u=d("h1",{id:"生命周期",tabindex:"-1"},[e("生命周期 "),d("a",{class:"header-anchor",href:"#生命周期","aria-label":'Permalink to "生命周期"'},"​")],-1),g=i('<table><thead><tr><th style="text-align:left;">生命周期</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">beforeCreate</td><td style="text-align:left;">组件实例被创建之初</td></tr><tr><td style="text-align:left;">created</td><td style="text-align:left;">组件实例已经完全创建</td></tr><tr><td style="text-align:left;">beforeMount</td><td style="text-align:left;">组件挂载之前</td></tr><tr><td style="text-align:left;">mounted</td><td style="text-align:left;">组件挂载到实例上去之后</td></tr><tr><td style="text-align:left;">beforeUpdate</td><td style="text-align:left;">组件数据发生变化，更新之前</td></tr><tr><td style="text-align:left;">updated</td><td style="text-align:left;">组件数据更新之后</td></tr><tr><td style="text-align:left;">beforeDestroy</td><td style="text-align:left;">组件实例销毁之前</td></tr><tr><td style="text-align:left;">destroyed</td><td style="text-align:left;">组件实例销毁之后</td></tr><tr><td style="text-align:left;">activated</td><td style="text-align:left;">keep-alive 缓存的组件激活时</td></tr><tr><td style="text-align:left;">deactivated</td><td style="text-align:left;">keep-alive 缓存的组件停用时调用</td></tr><tr><td style="text-align:left;">errorCaptured</td><td style="text-align:left;">捕获一个来自子孙组件的错误时被调用</td></tr></tbody></table><p><img src="https://static.vue-js.com/44114780-3aca-11eb-85f6-6fac77c0c9b3.png" alt="" loading="lazy"></p><p><strong>beforeCreate -&gt; created</strong></p><ul><li>初始化<code>vue</code>实例，进行数据观测</li></ul><p><strong>created</strong></p><ul><li>完成数据观测，属性与方法的运算，<code>watch</code>、<code>event</code>事件回调的配置</li><li>可调用<code>methods</code>中的方法，访问和修改data数据触发响应式渲染<code>dom</code>，可通过<code>computed</code>和<code>watch</code>完成数据计算</li><li>此时<code>vm.$el</code> 并没有被创建</li></ul><p><strong>created -&gt; beforeMount</strong></p><ul><li>判断是否存在<code>el</code>选项，若不存在则停止编译，直到调用<code>vm.$mount(el)</code>才会继续编译</li><li>优先级：<code>render</code> &gt; <code>template</code> &gt; <code>outerHTML</code></li><li><code>vm.el</code>获取到的是挂载<code>DOM</code>的</li></ul><p><strong>beforeMount</strong></p><ul><li>在此阶段可获取到<code>vm.el</code></li><li>此阶段<code>vm.el</code>虽已完成DOM初始化，但并未挂载在<code>el</code>选项上</li></ul><p><strong>beforeMount -&gt; mounted</strong></p><ul><li>此阶段<code>vm.el</code>完成挂载，<code>vm.$el</code>生成的<code>DOM</code>替换了<code>el</code>选项所对应的<code>DOM</code></li></ul><p><strong>mounted</strong></p><ul><li><code>vm.el</code>已完成<code>DOM</code>的挂载与渲染，此刻打印<code>vm.$el</code>，发现之前的挂载点及内容已被替换成新的DOM</li></ul><p><strong>beforeUpdate</strong></p><ul><li>更新的数据必须是被渲染在模板上的（<code>el</code>、<code>template</code>、<code>render</code>之一）</li><li>此时<code>view</code>层还未更新</li><li>若在<code>beforeUpdate</code>中再次修改数据，不会再次触发更新方法</li></ul><p><strong>updated</strong></p><ul><li>完成<code>view</code>层的更新</li><li>若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</li></ul><p><strong>beforeDestroy</strong></p><ul><li>实例被销毁前调用，此时实例属性与方法仍可访问</li></ul><p><strong>destroyed</strong></p><ul><li>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</li><li>并不能清除DOM，仅仅销毁实例</li></ul><h2 id="实例挂载的过程" tabindex="-1">实例挂载的过程 <a class="header-anchor" href="#实例挂载的过程" aria-label="Permalink to &quot;实例挂载的过程&quot;">​</a></h2><p>Vue 实例的挂载过程是一个相对复杂但有序的过程，它涉及到 Vue 的内部机制以及 DOM 的操作。下面是一个简化的 Vue 实例挂载过程的概述：</p><ol><li><strong>创建 Vue 实例</strong>：首先，我们使用 <code>new Vue({...})</code> 来创建一个 Vue 实例。在这个对象中，我们可以定义数据（<code>data</code>）、方法（<code>methods</code>）、生命周期钩子（<code>lifecycle hooks</code>）等。</li><li><strong>初始化</strong>：Vue 在内部进行了一系列的初始化操作。这包括解析选项、设置响应式数据、解析模板等。在这个过程中，Vue 会遍历 <code>data</code> 中的每一个属性，并使用 Object.defineProperty 将它们转化为 getter/setter，以实现数据的响应式。</li><li><strong>编译模板</strong>：如果提供了模板（可以是字符串形式的模板，也可以是挂载点元素的 in-DOM HTML），Vue 会将其编译成渲染函数的字符串形式。这个过程涉及到解析模板语法、生成虚拟 DOM 等步骤。</li><li><strong>生成渲染函数</strong>：编译后的模板字符串会被转换成 JavaScript 的渲染函数。这个渲染函数是一个纯 JavaScript 函数，当数据发生变化时，它会根据最新的数据生成一个新的虚拟 DOM 树。</li><li><strong>挂载过程开始</strong>：在 Vue 实例的 <code>$mount</code> 方法被调用时，挂载过程正式开始。如果没有提供 <code>el</code> 选项，则 Vue 实例会处于“未挂载”状态，此时可以通过 <code>$mount(elementOrSelector)</code> 手动挂载到一个元素上。</li><li><strong>创建根虚拟节点</strong>：使用之前生成的渲染函数，Vue 会根据当前的数据状态生成一个根虚拟节点（Virtual Node）。这个虚拟节点是 Vue 用来描述真实 DOM 结构的一个轻量级对象。</li><li><strong>创建或更新真实 DOM</strong>：Vue 使用一个名为 <code>patch</code> 的函数来比较旧的虚拟 DOM 和新的虚拟 DOM，并找出它们之间的差异。然后，Vue 会根据这些差异来更新真实的 DOM。这个过程被称为“差异算法”或“虚拟 DOM diffing”。</li><li><strong>挂载完成</strong>：当真实 DOM 被更新以匹配虚拟 DOM 后，Vue 实例就成功挂载到了指定的元素上。此时，Vue 实例会触发 <code>mounted</code> 生命周期钩子。</li></ol>',25);function p(f,m,y,_,h,x){const t=r("Bookmark");return n(),a("div",null,[u,o(t,null,{default:l(()=>[e("![Vue2生命周期](https://v2.cn.vuejs.org/images/lifecycle.png)")]),_:1}),o(t,null,{default:l(()=>[e("![Vue3生命周期](https://cn.vuejs.org/assets/lifecycle.16e4c08e.png)")]),_:1}),g])}const M=c(s,[["render",p]]);export{V as __pageData,M as default};
