import{_ as a,c as l,o as t,a4 as i,ax as e,ay as s,az as o,aA as n,aB as r}from"./chunks/framework.2gWjYe7W.js";const H=JSON.parse('{"title":"HTTP的发展1.1/2/3","description":"","frontmatter":{},"headers":[],"relativePath":"net/09.md","filePath":"net/09.md","lastUpdated":null}'),p={name:"net/09.md"},c=i('<h1 id="http的发展1-1-2-3" tabindex="-1">HTTP的发展1.1/2/3 <a class="header-anchor" href="#http的发展1-1-2-3" aria-label="Permalink to &quot;HTTP的发展1.1/2/3&quot;">​</a></h1><h2 id="http2" tabindex="-1">HTTP2 <a class="header-anchor" href="#http2" aria-label="Permalink to &quot;HTTP2&quot;">​</a></h2><p>HTTP/2 主要的⽬标就是改进性能，兼容 HTTP/1.1。</p><p><img src="'+e+'" alt="" loading="lazy"></p><ul><li>问题1： HTTP/1.1 需要开启多个tcp连接，消耗性能。</li><li>问题2： HTTP/1.1 采用纯文本格式，在解析过程中会有歧义，性能差。</li><li>问题3： HTTP/1.1 不能乱序收发。</li><li>问题4： HTTP/1.1 中只能优化 body 并没有对头部进⾏处理</li></ul><h3 id="_1-多路复用" tabindex="-1">1. 多路复用 <a class="header-anchor" href="#_1-多路复用" aria-label="Permalink to &quot;1. 多路复用&quot;">​</a></h3><p>在⼀条TCP链接上可以乱序收发请求和响应，多个请求和响应之间不再有顺序关系。</p><p><img src="'+s+'" alt="" loading="lazy"></p><ul><li>有序，每一个流都有特定ID。奇数为客户端发送，偶数为服务端发送</li><li>双向，同一个流内，可以接受和发送消息。</li><li>并行，同一个TCP中，可以发送多个流。</li><li>创建、关闭，客户端和服务端都可以主动关闭当前流。</li></ul><h3 id="_2-二进制帧" tabindex="-1">2. 二进制帧 <a class="header-anchor" href="#_2-二进制帧" aria-label="Permalink to &quot;2. 二进制帧&quot;">​</a></h3><p><img src="'+o+'" alt="" loading="lazy"></p><ul><li>Length帧的⼤⼩， 2^24 帧最⼤不能超过 16M</li><li>Type帧的类型：常⽤的就是 HEADERS，DATA</li><li>Flags标志位：常⽤的是 END_HEADERS , END_STREAM , PRIORITY</li><li>Stream Identifier 流的标号</li></ul><blockquote><p>/Applications/chrome.app/Contents/MacOS/Google\\ Chrome --ssl-key-log-file=/Users/jiangwen/tls/sslkeylog.log</p></blockquote><h3 id="_3-头部压缩" tabindex="-1">3. 头部压缩 <a class="header-anchor" href="#_3-头部压缩" aria-label="Permalink to &quot;3. 头部压缩&quot;">​</a></h3><p>使⽤ HPACK 算法压缩HTTP头</p><ul><li>废除起始⾏，全部移⼊到Header中去，采⽤<strong>静态表</strong>的⽅式压缩字段</li><li>如果是⾃定义Header，在发送的过程中会添加到<strong>静态表</strong>后，也就是所谓的<strong>动态表</strong></li><li>对内容进⾏哈夫曼编码来减⼩体积</li></ul><p><img src="'+n+`" alt="" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>a-&gt;0  b-&gt;1 c-&gt;10 d-&gt;11  错误编码有歧义</span></span>
<span class="line"><span>a-&gt;00 b-&gt;01 c-&gt;10 d-&gt;11 f-&gt;110 无歧义</span></span></code></pre></div><h3 id="_4-服务端推送" tabindex="-1">4. 服务端推送 <a class="header-anchor" href="#_4-服务端推送" aria-label="Permalink to &quot;4. 服务端推送&quot;">​</a></h3><p>服务端可以提前将可能会⽤到的资源主动推送到客户端。</p><h2 id="http3" tabindex="-1">HTTP3 <a class="header-anchor" href="#http3" aria-label="Permalink to &quot;HTTP3&quot;">​</a></h2><p>TCP为了保证可靠传输，如果在传输的过程中发⽣丢包，可能此时其他包已经接受完毕，但是仍要等待客户端重传丢失的包。这就是TCP协议本身队头阻塞的问题。</p><p><img src="`+r+'" alt="" loading="lazy"></p><ul><li>HTTP/3中关键的改变，那就是把下层的 TCP 换成了 UDP 。 UDP ⽆序从⽽解决了<strong>队头阻塞</strong>的问题。</li><li>QUIC 基于 UDP 之前说过 UDP 是⽆续的，连接速度⽐ TCP 快。</li><li>QUIC 基于 UDP 实现了可靠传输、流量控制，引⼊流和多路复⽤。</li><li>QUIC 全⾯采⽤加密通信, QUIC 使⽤了 TLS 1.3，⾸次连接只需要 1RTT。</li><li>⽀持<strong>链接迁移</strong>，不受 IP 及 port 影响⽽发⽣重连，通过 ConnectionID 进⾏链接。</li><li>使⽤ QPACK 进⾏头部压缩，提供更好的压缩比、更快的压缩和解压缩速度以及更大的灵活性。</li></ul>',24),h=[c];function d(T,_,g,P,u,m){return t(),l("div",null,h)}const C=a(p,[["render",d]]);export{H as __pageData,C as default};
