import{_ as e,c as t,o as a,a4 as o,aw as d}from"./chunks/framework.2gWjYe7W.js";const _=JSON.parse('{"title":"HTTP 常见的请求头有哪些","description":"","frontmatter":{},"headers":[],"relativePath":"net/08.md","filePath":"net/08.md","lastUpdated":null}'),i={name:"net/08.md"},l=o('<h1 id="http-常见的请求头有哪些" tabindex="-1">HTTP 常见的请求头有哪些 <a class="header-anchor" href="#http-常见的请求头有哪些" aria-label="Permalink to &quot;HTTP 常见的请求头有哪些&quot;">​</a></h1><p>HTTP 头是在 HTTP 请求和响应中包含的元数据信息，用于传递关于消息的附加信息。HTTP 协议定义了一些标准的头字段，这些头字段有明确定义的含义和用途。同时 HTTP 头部字段也可以根据需要自定义。</p><h2 id="内容协议" tabindex="-1">内容协议 <a class="header-anchor" href="#内容协议" aria-label="Permalink to &quot;内容协议&quot;">​</a></h2><table><thead><tr><th>客户端 Header</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>用于客户端指定其所期望的响应的媒体类型（即内容类型）</td></tr><tr><td>Accept- encoding</td><td>客户端指定所需的编码方式。</td></tr><tr><td>Accept- language</td><td>客户端向服务器传递其首选的自然语言或语言区域设置。</td></tr><tr><td>Range</td><td>用于请求服务器发送部分响应内容而不是完整的资源。</td></tr></tbody></table><table><thead><tr><th>服务端 Header</th><th>描述</th></tr></thead><tbody><tr><td>Content-Type</td><td>用于指定响应体的多媒体类型。</td></tr><tr><td>Content- Encoding</td><td>用于指定响应主体内容的编码方式。</td></tr><tr><td>Content- Range</td><td>用于指定响应主体内容的部分范围。</td></tr><tr><td>Content-Length</td><td>用于指定响应主体内容的字节长度。</td></tr></tbody></table><h2 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h2><h3 id="强缓存-expires-cache-control" tabindex="-1">强缓存 Expires/Cache-Control <a class="header-anchor" href="#强缓存-expires-cache-control" aria-label="Permalink to &quot;强缓存 Expires/Cache-Control&quot;">​</a></h3><p>服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应 header 中。强制缓存存在有效期，缓存期内不会向服务端发送请求。超过时间后需要去服务端验证是否是最新版本。</p><p><img src="'+d+'" alt="" loading="lazy"></p><blockquote><p>HTTP/1.1 建议使用 Cache-Control 头（Expires 有时间同步问题），同时设置时Cache-Control优先级更高，而且缓存控制更丰富。</p></blockquote><ul><li><code>public</code>：表示响应可以被共享缓存（如代理服务器）存储。</li><li><code>private</code>：表示响应只能被客户端缓存，不应该被共享缓存存储。</li><li><code>max-age</code>：指定响应可以被缓存的最长时间，以秒为单位。</li><li><code>no-store</code>：表示响应不应被缓存，客户端必须始终从服务器获取最新内容。</li><li><code>no-cache</code>：表示客户端必须在使用缓存之前先验证响应的新鲜度。</li></ul><h3 id="对比缓存-if-modified-since-if-none-match" tabindex="-1">对比缓存 If-Modified-Since / If-None-Match <a class="header-anchor" href="#对比缓存-if-modified-since-if-none-match" aria-label="Permalink to &quot;对比缓存 If-Modified-Since / If-None-Match&quot;">​</a></h3><ul><li>时间戳是秒级的，因此可能不足以检测非常小的变化。</li><li>对于分布式服务器来说，最后修改时间可能不够精确，因为不同服务器可能有不同的时间设置。</li></ul><h3 id="对比缓存-last-modified-etag" tabindex="-1">对比缓存 Last-Modified/Etag <a class="header-anchor" href="#对比缓存-last-modified-etag" aria-label="Permalink to &quot;对比缓存 Last-Modified/Etag&quot;">​</a></h3><ul><li>ETag 可以表示资源内容的更精确的变化，包括内容的任何更改。</li><li>需要服务器生成和维护 ETag 开销大。</li></ul><blockquote><p>绝大多数情况下，采用 ETag（基于最后修改时间和资源长度生成）进行对比缓存是最常见的方式，因为它既减少了计算开销，又提供了足够的准确性。</p></blockquote><h2 id="客户端常用的header" tabindex="-1">客户端常用的header <a class="header-anchor" href="#客户端常用的header" aria-label="Permalink to &quot;客户端常用的header&quot;">​</a></h2><ul><li><code>User-Agent</code>：用于标识客户端（例如浏览器）的类型和版本。</li><li><code>Cookie</code>：用于在客户端和服务器之间传递状态信息。</li><li><code>Authorization</code>： 用于传递身份验证信息，以允许访问受保护的资源。</li><li><code>origin</code>：浏览器在跨域请求中发送，用于表示请求的来源。</li><li><code>referer</code>：指示当前请求的来源页面的 URL</li><li><code>host</code>：正在请求的服务器的主机名（域名）和端口号</li><li><code>Connection</code>： 用于指示客户端与服务器之间的连接属性，以及如何处理连接。</li></ul><h2 id="服务端常用的header" tabindex="-1">服务端常用的header <a class="header-anchor" href="#服务端常用的header" aria-label="Permalink to &quot;服务端常用的header&quot;">​</a></h2><ul><li><code>Server</code>： 用于标识服务器的软件和版本信息。</li><li><code>Date</code>： 用于指定消息的日期和时间。</li><li><code>Location</code>： 用于执行重定向，指示客户端应该跳转到的新 URL。</li><li><code>Set-Cookie</code>： 用于在客户端上设置和管理会话 cookie。</li></ul>',20),r=[l];function c(n,h,s,u,p,f){return a(),t("div",null,r)}const b=e(i,[["render",c]]);export{_ as __pageData,b as default};
