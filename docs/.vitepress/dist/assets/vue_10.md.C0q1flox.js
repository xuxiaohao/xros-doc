import{_ as e,c as a,o as t,a4 as o,aS as l}from"./chunks/framework.2gWjYe7W.js";const m=JSON.parse('{"title":"Vue 中 key 的作用和原理","description":"","frontmatter":{},"headers":[],"relativePath":"vue/10.md","filePath":"vue/10.md","lastUpdated":null}'),i={name:"vue/10.md"},r=o('<h1 id="vue-中-key-的作用和原理" tabindex="-1">Vue 中 key 的作用和原理 <a class="header-anchor" href="#vue-中-key-的作用和原理" aria-label="Permalink to &quot;Vue 中 key 的作用和原理&quot;">​</a></h1><h2 id="key的概念" tabindex="-1">key的概念 <a class="header-anchor" href="#key的概念" aria-label="Permalink to &quot;key的概念&quot;">​</a></h2><ul><li><code>key</code> 主要用在Vue的虚拟DOM算法中，在新旧nodes对比时辨识VNodes。 如果不实用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。</li><li>当Vue正在更新使用<code>v-for</code>渲染的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序被改变，Vue将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置都正确渲染。</li></ul><h2 id="key的作用" tabindex="-1">key的作用 <a class="header-anchor" href="#key的作用" aria-label="Permalink to &quot;key的作用&quot;">​</a></h2><ul><li>Vue在patch过程中通过key可以判断两个虚拟节点是否是相同节点。</li><li>无key会导致更新的时候出问题（样式，动画，事件等）。</li><li>尽量不要采用索引index作为key。 <img src="'+l+'" alt="" loading="lazy"></li></ul>',5),s=[r];function d(c,n,_,u,k,h){return t(),a("div",null,s)}const p=e(i,[["render",d]]);export{m as __pageData,p as default};
