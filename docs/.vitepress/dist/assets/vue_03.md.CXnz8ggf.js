import{_ as e,c as a,o as l,a4 as o}from"./chunks/framework.2gWjYe7W.js";const m=JSON.parse('{"title":"Vue 为什么需要虚拟 DOM?","description":"","frontmatter":{},"headers":[],"relativePath":"vue/03.md","filePath":"vue/03.md","lastUpdated":null}'),t={name:"vue/03.md"},i=o('<h1 id="vue-为什么需要虚拟-dom" tabindex="-1">Vue 为什么需要虚拟 DOM? <a class="header-anchor" href="#vue-为什么需要虚拟-dom" aria-label="Permalink to &quot;Vue 为什么需要虚拟 DOM?&quot;">​</a></h1><h2 id="_1-基本概念" tabindex="-1">1. 基本概念 <a class="header-anchor" href="#_1-基本概念" aria-label="Permalink to &quot;1. 基本概念&quot;">​</a></h2><blockquote><p>基本上所有框架都引入了虚拟 DOM 来对真实 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM</p></blockquote><ul><li>Virtual DOM 就是用 js 对象来描述真实 DOM，是对真实 DOM 的抽象，由于直接操作 DOM 性能低但是 js 层的操作效率高，可以将 DOM 操作转化成对象操作，最终通过 diff 算法比对差异进行更新 DOM（减少了对真实 DOM 的操作）。</li><li>虚拟 DOM 不依赖真实平台环境从而也可以实现跨平台。</li></ul><h2 id="_2-vdom是如何生成的" tabindex="-1">2. VDOM是如何生成的？ <a class="header-anchor" href="#_2-vdom是如何生成的" aria-label="Permalink to &quot;2. VDOM是如何生成的？&quot;">​</a></h2><ul><li>在 vue 中我们常常会为组件编写模板 - template</li><li>这个模板会被编译器编译为渲染函数 - render</li><li>在接下来的挂载过程中会调用 render 函数，返回的对象就是虚拟 dom</li><li>会在后续的 patch 过程中进一步转化为 真实 dom。</li></ul><h2 id="_3-vdom如何做diff的" tabindex="-1">3. VDOM如何做diff的？ <a class="header-anchor" href="#_3-vdom如何做diff的" aria-label="Permalink to &quot;3. VDOM如何做diff的？&quot;">​</a></h2><ul><li>挂载过程结束后，会记录第一次生成的 VDOM - oldVnode</li><li>当响应式数据发生变化时，将会引起组件重新 render，此时就会生成新的 VDOM - newVnode</li><li>使用 oldVnode 与 newVnode 做 diff 操作，将更改的部分应到真实 DOM 上，从而转换为最小量的 dom 操作，高效更新视图。</li></ul>',8),d=[i];function r(n,_,s,u,c,h){return l(),a("div",null,d)}const D=e(t,[["render",r]]);export{m as __pageData,D as default};
